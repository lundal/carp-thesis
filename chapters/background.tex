\TODO

\begin{itemize}
    \item EHW
    \item POE
\end{itemize}

%==============================================================================%

\section{Artificial Evolution}

\TODO

\begin{itemize}
    \item Antenna design
    \item Robot controllers
\end{itemize}

\subsection{Genetic Algoritmhs}

\TODO

\begin{itemize}
    \item Select, Cross, Mutate
    \item Genotype to Phenotype
\end{itemize}

\subsection{Evolution in Materio}

\TODO

%==============================================================================%

\section{Artificial Development}

\TODO

\begin{itemize}
    \item Attractors
    \item Adaptation
    \item Graceful degradation
\end{itemize}

\subsection{Lindenmayer Systems}

\TODO

%==============================================================================%

\section{Cellular Automata}

\TODO

\begin{itemize}
    \item Massively parallel
    \item Local interactions
    \item Simple units
    \item Discrete vs Continuous
    \item Exhaustive enumeration vs Parameterized vs others
    \item Synchronous vs not
    \item Uniform vs not
    \item Deterministic vs not
    \item Direct programming vs Adaptive (evolution)
    \item Input/Output
    \item Scalability
    \item Robustness
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.90\textwidth]{computing-principles}
    \caption[Computing principles]{
        Graphical representation of how different computing paradigmes relate with regards to computing principles.
        (Reprinted from \cite{sipper1999emergence})
    }
    \label{fig:computing-principles}
\end{figure}

\subsection{Neighborhoods}

\begin{itemize}
    \item Regular grid vs graph
    \item 1D vs 2D vs 3D
    \item Full vs von Neumann
\end{itemize}

\subsection{Complexity Classes}

\begin{itemize}
    \item Class 1 - Uniform
    \item Class 2 - Repetitive patterns
    \item Class 3 - Chaos
    \item Class 4 - Complex
\end{itemize}

%==============================================================================%

\section{FPGA}

A Field Programmable Gate Array (FPGA) is a type of reconfigurable hardware.
It can implement any desired logical operation by configuring and connecting a number of look-up tables (LUTs) and flip-flops (FFs).
FPGAs can also contain dedicated blocks for addition, multiplication, storage, and other functions.
These elements are grouped into configurable logic blocks (CLBs), which through a network of interconnects can be connected to each other or input/output pins.
An example of this structure is shown in \figurename~\ref{fig:fpga}.
Note that modern FPGAs consists of thousands of CLBs and hundreds of I/O pins \cite{ds160}.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.60\textwidth]{fpga}
    \caption[FPGA]{
        High-level block diagram of an FPGA.
        An array of configurable logic blocks (CLBs) and input/output blocks (IOBs) are connected by a network of interconnects.
    }
    \label{fig:fpga}
\end{figure}

FPGAs have been the subject of EHW research due to their reconfigurability, and several researchers have been successful in evolving working electronic circuits \cite{huelsbergen1998evolution} \cite{thompson1997evolved}.
However, the resulting circuits have often ended up using intrinsic properties of the silicon and been very sensitive to environmental changes.

A problem with using modern FPGAs for EHW research is that some configuration bitstrings can destroy the FPGA by creating short-circuits \cite{ug380} \cite{xapp151}.
This means that the bitstrings can not be used directly as the genotype without complicated tests to discard those that are dangerous.

\subsection{Sblock}

The sblock was introduced as part of a new EHW-friendly FPGA architecture in \cite{haddow2000sblock}.
The architecture is a non-uniform CA with a von Neumann neighborhood, where the update function of each cell is independently configurable at run-time.
The cells, known as sblocks, are very simple structures; they consist of a configurable look-up-table (LUT) and a flip-flop (FF), as shown in \figurename~\ref{fig:sblock}.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.5\textwidth]{sblock}
    \caption[Sblock]{
        Detailed block diagram of an sblock.
        The LUT can be reconfigured on-the-fly to implement any logical function.
    }
    \label{fig:sblock}
\end{figure}

The greatest benefit of using sblocks for EHW research is that there is no risk of damage or exploitation of intrinsic properties in the silicon.
Additionaly, the simple structure and hardwired signal routing allows for very efficient area usage.
The likelihood of a mass-produced sblock-FPGA arriving on the market in the near future is slim.
However, it is possible to implement it virtually within an other FPGA.

%==============================================================================%

\section{PCI Express}

The PCI Express interface was designed to tackle the arising trouble with clocked parallel buses like PCI.
The problem with such buses is that the clock speed can not be increased beyond a given threshold, as the slightly different lengths of the wires causes data to arrive at slightly different times.
Reducing the clock period to less than the variation in arrival time means the data will become corrupted.
This problem is exacerbated with increasing bus size.

PCI Express is therefore based on serial communication over differential pairs (lanes\footnotemark) without the need for a reference clock \cite{pcie}.
\footnotetext{
    PCI Express operates in full duplex mode, which means that each lane has an independent differential pair in each direction.
    1, 2, 4, 8, 16 or 32 lanes are supported, but data is striped and thus still transmitted serially.
}
This allows an extremely fast clock speed compared to a parallel bus, and much greater bandwidth in total.
PCI Express consists of three layers; the physical layer, the data link layer and the transaction layer, structured as shown in \figurename~\ref{fig:pcie}.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.5\textwidth]{pcie}
    \caption[PCI Express structure]{
        High-level diagram showing the layered structure of PCI Express. (Reprinted from \cite{pcie})
    }
    \label{fig:pcie}
\end{figure}

The transaction layer's primary responsibility is the creation and parsing of transaction layer packets (TLPs).
TLPs are used to trigger events or start various transactions, most commonly to initiate read and write requests\footnotemark.
\footnotetext{
    Read and write requests are directed at one of up to six base address registers (BARs).
    They represent internal memory areas that can be anywhere from a few bytes to several gigabytes in size.
}
Most requests entail the return of a completion TLP containing the requested data or other information.
TLPs consists of multiple 32-bit double words (DW), where the first is a common header describing the type of packet.

The data link layer ensures integrity by adding error detection codes to outgoing TLPs and performing error detection and correction on incoming TLPs.
It is also responsible for retransmission if corruption occurs.

The physical layer is responsible for serialization and deserialization of the data stream.
Each byte is padded with two extra bits (8b/10b encoding) to allow clock recovery.

%==============================================================================%

\section{Related Work}

\TODO

\subsection{CAM-8}

\begin{itemize}
    \item Cellular Automata Machine
    \item Semi-parallel CA simulator
    \item Indefinitely scalable 3D mesh-network multiprocessor
    \item Optimized for large inexpensive simulations
    \item Prototype faster than existing supercomputers
    \item Hope to whet the apetite of researchers with computing power
    \item Time-sharing of com resources interprocessor wires, allows scalability to be achieved with current tech
    \item Node: DRAM with millions of cells, SRAM look-up table
    \item Nodes update cells seqentially
    \item 3G site updates per second
    \item No traditional CA neighborhoods: Based on partitioning from lattice gas models (shifts bits around)
    \item Good at spatially moving data and interaction at lattice sites: Well suited for simulating physical systems using lattice-gas-like dynamics or localized interactions.
    \item Goal to bring computation closer to physics to improve computation
    \item Harness the astronomical computing power that is available in CA format
\end{itemize}

\subsection{CAM-Brain Machine}

\begin{itemize}
    \item FPGA based hardware that implements a GA to evolve CA based neural network with 1000 neurons in approx 1 second
    \item Part of CAM-Brain project: Goal to build a brain with 1 billion neurons
    \item New research field called "Brain Building"
    \item Up to 65K modules can be interconnected in a large RAM
    \item Modules are evolved and connected by human design
    \item Artificial brain with up to 70M neurons
    \item Updated at 130G cells per second. Enough for real-time robot control
    \item CoDi-1bit (Collect and Distribute), maybe more in future
    \item Spike Interval Information Coding: "spike train" to analog
    \item Hough Spiker Algorithm: Analog to "spike train"
    \item Goal to have 500 times faster update times compared to CAM-8 for (50-100 updates 10-20 times per second)
    \item Cells can be neuron, axon or dendrite
    \item Each module has 24x24x24 cells, can receive 1-bit signals from 188 other modules and send to 64640
    \item Neuron has 4-bit accumulator and threshold function, inputs can be subtractive
    \item Dendrites pass XOR of inputs
    \item Axons pass input to all others
    \item Dendrites and Axons grown interchangedly
    \item Signals representation: Custom convolution function (SIIC)
    \item "Function-level" evolvable hardware
    \item Cells have 6-bit register and other logic for com
    \item Each FPGA has 8x6x4 cells
    \item Fast reconfiguration (<1ms)of the FPGA between growth, signaling and genetic phases to save resources
    \item Controllable object to attract attention and be proof-of-consept: Robokitty
    \item "An assemblage of evolved CA based neural net modules"
\end{itemize}
